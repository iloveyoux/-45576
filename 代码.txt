1./*-------------------------------------------
2.                Includes
3.-------------------------------------------*/
4.
5.#include <stdio.h>
6.#include <stdlib.h>
7.#include <string.h>
8.#include <iostream>
9.#include <fstream>
10.#include <cstdlib>
11.#include <thread>
12.#include <mutex>
13.#include <atomic>
14.#include "opencv2/opencv.hpp"
15.#include "opencv2/highgui.hpp"
16.#include "postprocess.h"
17.#include "rknn_api.h"
18.
19./*-------------------------------------------
20.        â­â­â­ é…ç½®å‚æ•° - åœ¨è¿™é‡Œä¿®æ”¹ â­â­â­
21.-------------------------------------------*/
22.
23.// æ¨¡å‹æ–‡ä»¶è·¯å¾„
24.const char* MODEL_PATH = "../model/yolov5s.rknn";
25.
26.// åŒæ‘„åƒå¤´é…ç½®
27.const int CAMERA_1_ID = 0;                  // æ‘„åƒå¤´1è®¾å¤‡ ID (/dev/video0)
28.const int CAMERA_2_ID = 2;                  // æ‘„åƒå¤´2è®¾å¤‡ ID (/dev/video2)
29.const int CAMERA_WIDTH = 640;               // æ‘„åƒå¤´åˆ†è¾¨ç‡å®½åº¦
30.const int CAMERA_HEIGHT = 480;              // æ‘„åƒå¤´åˆ†è¾¨ç‡é«˜åº¦
31.const int CAMERA_FPS = 30;                  // æ‘„åƒå¤´å¸§ç‡
32.
33.// æ£€æµ‹é˜ˆå€¼å‚æ•°
34.const float BOX_CONFIDENCE_THRESHOLD = 0.25;  // ç½®ä¿¡åº¦é˜ˆå€¼
35.const float NMS_THRESHOLD = 0.45;             // NMSé˜ˆå€¼
36.
37.// æ˜¾ç¤ºé…ç½®
38.const char* WINDOW_TITLE = "YOLOv5 Dual Camera Detection";
39.const bool SHOW_FPS = true;
40.
41./*-------------------------------------------
42.            å…¨å±€å˜é‡ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
43.-------------------------------------------*/
44.
45.std::atomic<bool> g_running(true);           // ç¨‹åºè¿è¡Œæ ‡å¿—
46.std::atomic<int> g_current_camera(CAMERA_1_ID);  // å½“å‰ä½¿ç”¨çš„æ‘„åƒå¤´ID
47.std::atomic<bool> g_switch_requested(false); // åˆ‡æ¢è¯·æ±‚æ ‡å¿—
48.std::mutex g_mutex;                          // äº’æ–¥é”
49.
50./*-------------------------------------------
51.                  Functions
52.-------------------------------------------*/
53.
54.static void dump_tensor_attr(rknn_tensor_attr* attr)
55.{
56.  printf("\tindex=%d, name=%s, \n\t\tn_dims=%d, dims=[%d, %d, %d, %d], \n\t\tn_elems=%d, size=%d, fmt=%s, \n\t\ttype=%s, qnt_type=%s, "
57.         "zp=%d, scale=%f\n",
58.         attr->index, attr->name, attr->n_dims, attr->dims[0], attr->dims[1], attr->dims[2], attr->dims[3],
59.         attr->n_elems, attr->size, get_format_string(attr->fmt), get_type_string(attr->type),
60.         get_qnt_type_string(attr->qnt_type), attr->zp, attr->scale);
61.}
62.
63.static unsigned char* load_model(const char* filename, int& fileSize) {
64.    std::ifstream file(filename, std::ios::binary | std::ios::ate);
65.
66.    if (!file.is_open()) {
67.        std::cerr << "Failed to open file: " << filename << std::endl;
68.        return nullptr;
69.    }
70.
71.    fileSize = (int) file.tellg();
72.    file.seekg(0, std::ios::beg);
73.
74.    char* buffer = (char*)malloc(fileSize);
75.
76.    if (!buffer) {
77.        std::cerr << "Memory allocation failed." << std::endl;
78.        return nullptr;
79.    }
80.
81.    file.read(buffer, fileSize);
82.    file.close();
83.
84.    return (unsigned char*) buffer;
85.}
86.
87.// â­ æ‰“å¼€æ‘„åƒå¤´å‡½æ•°
88.cv::VideoCapture open_camera(int camera_id) {
89.    printf("\nğŸ“¹ Opening camera /dev/video%d...\n", camera_id);
90.    cv::VideoCapture cap(camera_id);
91.
92.    if (!cap.isOpened()) {
93.        printf("âŒ Error: Cannot open camera /dev/video%d\n", camera_id);
94.        return cap;
95.    }
96.
97.    // è®¾ç½®æ‘„åƒå¤´å‚æ•°
98.    cap.set(cv::CAP_PROP_FRAME_WIDTH, CAMERA_WIDTH);
99.    cap.set(cv::CAP_PROP_FRAME_HEIGHT, CAMERA_HEIGHT);
100.    cap.set(cv::CAP_PROP_FPS, CAMERA_FPS);
101.    cap.set(cv::CAP_PROP_BUFFERSIZE, 1);
102.
103.    int actual_width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
104.    int actual_height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);
105.    int actual_fps = cap.get(cv::CAP_PROP_FPS);
106.
107.    printf("âœ… Camera %d opened: %dx%d @ %d FPS\n", camera_id, actual_width, actual_height, actual_fps);
108.
109.    return cap;
110.}
111.
112.// â­ è¾“å…¥ç›‘å¬çº¿ç¨‹å‡½æ•°
113.void input_listener_thread() {
114.    std::string input;
115.    printf("\n========================================\n");
116.    printf("ğŸ“ Input Commands:\n");
117.    printf("  - Type 'convert' or 'c' to switch camera\n");
118.    printf("  - Type 'exit' or 'q' to quit\n");
119.    printf("========================================\n\n");
120.
121.    while (g_running) {
122.        std::cout << ">> ";
123.        std::getline(std::cin, input);
124.
125.        // è½¬æ¢ä¸ºå°å†™
126.        std::transform(input.begin(), input.end(), input.begin(), ::tolower);
127.
128.        if (input == "convert" || input == "c") {
129.            g_switch_requested = true;
130.            printf("\nğŸ”„ Camera switch requested...\n");
131.        }
132.        else if (input == "exit" || input == "q") {
133.            printf("\nğŸ›‘ Exit requested...\n");
134.            g_running = false;
135.            break;
136.        }
137.        else if (!input.empty()) {
138.            printf("âš ï¸  Unknown command: '%s'\n", input.c_str());
139.            printf("   Valid commands: convert, c, exit, q\n");
140.        }
141.    }
142.}
143.
144./*-------------------------------------------
145.                  Main Functions
146.-------------------------------------------*/
147.int main(int argc, char** argv)
148.{
149.    rknn_context   ctx;
150.    int            ret;
151.
152.    float f;
153.    float FPS[16];
154.    int i, Fcnt=0;
155.    std::chrono::steady_clock::time_point Tbegin, Tend;
156.
157.    for(i=0;i<16;i++) FPS[i]=0.0;
158.
159.    const char* model_name = MODEL_PATH;
160.    const float nms_threshold = NMS_THRESHOLD;
161.    const float box_conf_threshold = BOX_CONFIDENCE_THRESHOLD;
162.
163.    printf("========================================\n");
164.    printf("  YOLOv5 RKNN Dual Camera Detection\n");
165.    printf("========================================\n");
166.    printf("Model: %s\n", model_name);
167.    printf("Camera 1: /dev/video%d\n", CAMERA_1_ID);
168.    printf("Camera 2: /dev/video%d\n", CAMERA_2_ID);
169.    printf("Resolution: %dx%d @ %d FPS\n", CAMERA_WIDTH, CAMERA_HEIGHT, CAMERA_FPS);
170.    printf("Box confidence threshold: %.2f\n", box_conf_threshold);
171.    printf("NMS threshold: %.2f\n", nms_threshold);
172.    printf("========================================\n");
173.
174.    // åŠ è½½æ¨¡å‹
175.    printf("\nğŸ“¦ Loading model...\n");
176.    int            model_data_size = 0;
177.    unsigned char* model_data      = load_model(model_name, model_data_size);
178.
179.    if (model_data == nullptr) {
180.        printf("âŒ Error: Failed to load model file: %s\n", model_name);
181.        return -1;
182.    }
183.
184.    ret = rknn_init(&ctx, model_data, model_data_size, 0, NULL);
185.    free(model_data);
186.
187.    if (ret < 0) {
188.        printf("âŒ rknn_init error ret=%d\n", ret);
189.        return -1;
190.    }
191.
192.    rknn_sdk_version version;
193.    ret = rknn_query(ctx, RKNN_QUERY_SDK_VERSION, &version, sizeof(rknn_sdk_version));
194.    if (ret < 0) {
195.        printf("âŒ rknn_query error ret=%d\n", ret);
196.        return -1;
197.    }
198.    printf("âœ… SDK version: %s, Driver version: %s\n", version.api_version, version.drv_version);
199.
200.    rknn_input_output_num io_num;
201.    ret = rknn_query(ctx, RKNN_QUERY_IN_OUT_NUM, &io_num, sizeof(io_num));
202.    if (ret < 0) {
203.        printf("âŒ rknn_query error ret=%d\n", ret);
204.        return -1;
205.    }
206.
207.    printf("\nğŸ“Š Model input num: %d\n", io_num.n_input);
208.    rknn_tensor_attr input_attrs[io_num.n_input];
209.    memset(input_attrs, 0, sizeof(input_attrs));
210.    for(uint32_t i = 0; i < io_num.n_input; i++) {
211.        input_attrs[i].index = i;
212.        ret = rknn_query(ctx, RKNN_QUERY_INPUT_ATTR, &(input_attrs[i]), sizeof(rknn_tensor_attr));
213.        if (ret < 0) {
214.            printf("âŒ rknn_query error ret=%d\n", ret);
215.            return -1;
216.        }
217.        dump_tensor_attr(&(input_attrs[i]));
218.    }
219.
220.    printf("\nğŸ“Š Model output num: %d\n", io_num.n_output);
221.    rknn_tensor_attr output_attrs[io_num.n_output];
222.    memset(output_attrs, 0, sizeof(output_attrs));
223.    for (uint32_t i = 0; i < io_num.n_output; i++) {
224.        output_attrs[i].index = i;
225.        ret = rknn_query(ctx, RKNN_QUERY_OUTPUT_ATTR, &(output_attrs[i]), sizeof(rknn_tensor_attr));
226.        dump_tensor_attr(&(output_attrs[i]));
227.    }
228.
229.    int channel = 3;
230.    int width   = 0;
231.    int height  = 0;
232.    if (input_attrs[0].fmt == RKNN_TENSOR_NCHW) {
233.        printf("\nğŸ“ Model input is NCHW\n");
234.        channel = input_attrs[0].dims[1];
235.        height  = input_attrs[0].dims[2];
236.        width   = input_attrs[0].dims[3];
237.    }
238.    else {
239.        printf("\nğŸ“ Model input is NHWC\n");
240.        height  = input_attrs[0].dims[1];
241.        width   = input_attrs[0].dims[2];
242.        channel = input_attrs[0].dims[3];
243.    }
244.
245.    printf("Model input: height=%d, width=%d, channel=%d\n", height, width, channel);
246.
247.    rknn_input inputs[1];
248.    memset(inputs, 0, sizeof(inputs));
249.    inputs[0].index        = 0;
250.    inputs[0].type         = RKNN_TENSOR_UINT8;
251.    inputs[0].size         = width * height * channel;
252.    inputs[0].fmt          = RKNN_TENSOR_NHWC;
253.    inputs[0].pass_through = 0;
254.
255.    // â­ å¯åŠ¨è¾“å…¥ç›‘å¬çº¿ç¨‹
256.    std::thread input_thread(input_listener_thread);
257.    input_thread.detach();  // åˆ†ç¦»çº¿ç¨‹ï¼Œè®©å®ƒç‹¬ç«‹è¿è¡Œ
258.
259.    // â­ æ‰“å¼€åˆå§‹æ‘„åƒå¤´ï¼ˆæ‘„åƒå¤´1ï¼‰
260.    cv::VideoCapture cap = open_camera(g_current_camera);
261.    if (!cap.isOpened()) {
262.        printf("âŒ Failed to open initial camera\n");
263.        g_running = false;
264.        rknn_destroy(ctx);
265.        return -1;
266.    }
267.
268.    cv::Mat orig_img;
269.    cv::Mat img;
270.    cv::Mat resized_img;
271.
272.    int frame_count = 0;
273.    int img_width = 0;
274.    int img_height = 0;
275.
276.    printf("\nğŸ¬ Starting detection loop...\n");
277.    printf("Press ESC in video window to exit\n\n");
278.
279.    // â­ ä¸»å¾ªç¯
280.    while(g_running){
281.        // â­ æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ¢æ‘„åƒå¤´
282.        if (g_switch_requested) {
283.            std::lock_guard<std::mutex> lock(g_mutex);
284.            
285.            // é‡Šæ”¾å½“å‰æ‘„åƒå¤´
286.            cap.release();
287.            printf("ğŸ”Œ Camera %d closed\n", g_current_camera.load());
288.
289.            // åˆ‡æ¢åˆ°å¦ä¸€ä¸ªæ‘„åƒå¤´
290.            if (g_current_camera == CAMERA_1_ID) {
291.                g_current_camera = CAMERA_2_ID;
292.            } else {
293.                g_current_camera = CAMERA_1_ID;
294.            }
295.
296.            // æ‰“å¼€æ–°æ‘„åƒå¤´
297.            cap = open_camera(g_current_camera);
298.            if (!cap.isOpened()) {
299.                printf("âŒ Failed to open camera %d, trying to reopen previous camera...\n", g_current_camera.load());
300.                
301.                // åˆ‡æ¢å›åŸæ¥çš„æ‘„åƒå¤´
302.                g_current_camera = (g_current_camera == CAMERA_1_ID) ? CAMERA_2_ID : CAMERA_1_ID;
303.                cap = open_camera(g_current_camera);
304.                
305.                if (!cap.isOpened()) {
306.                    printf("âŒ Failed to open any camera, exiting...\n");
307.                    g_running = false;
308.                    break;
309.                }
310.            }
311.
312.            printf("âœ… Now using Camera %d\n\n", g_current_camera.load());
313.            g_switch_requested = false;
314.            frame_count = 0;  // é‡ç½®å¸§è®¡æ•°
315.        }
316.
317.        // ä»æ‘„åƒå¤´è¯»å–ä¸€å¸§
318.        cap >> orig_img;
319.
320.        if(orig_img.empty()) {
321.            printf("âš ï¸  Warning: Cannot grab frame from camera %d\n", g_current_camera.load());
322.            std::this_thread::sleep_for(std::chrono::milliseconds(10));
323.            continue;
324.        }
325.
326.        frame_count++;
327.        Tbegin = std::chrono::steady_clock::now();
328.
329.        cv::cvtColor(orig_img, img, cv::COLOR_BGR2RGB);
330.        img_width  = img.cols;
331.        img_height = img.rows;
332.
333.        // è°ƒæ•´å›¾åƒå¤§å°
334.        if (img_width != width || img_height != height) {
335.            cv::resize(img, resized_img, cv::Size(width, height));
336.            inputs[0].buf = (void*)resized_img.data;
337.        } else {
338.            inputs[0].buf = (void*)img.data;
339.        }
340.
341.        rknn_inputs_set(ctx, io_num.n_input, inputs);
342.
343.        rknn_output outputs[io_num.n_output];
344.        memset(outputs, 0, sizeof(outputs));
345.        for (uint32_t i = 0; i < io_num.n_output; i++) {
346.            outputs[i].index = i;
347.            outputs[i].want_float = 0;
348.        }
349.
350.        rknn_run(ctx, NULL);
351.        rknn_outputs_get(ctx, io_num.n_output, outputs, NULL);
352.
353.        // Post process
354.        float scale_w = (float)width / img_width;
355.        float scale_h = (float)height / img_height;
356.
357.        detect_result_group_t detect_result_group;
358.        std::vector<float> out_scales;
359.        std::vector<int32_t> out_zps;
360.        for(uint32_t i = 0; i < io_num.n_output; ++i){
361.            out_scales.push_back(output_attrs[i].scale);
362.            out_zps.push_back(output_attrs[i].zp);
363.        }
364.
365.        post_process((int8_t *)outputs[0].buf, (int8_t *)outputs[1].buf, (int8_t *)outputs[2].buf, 
366.                     height, width, box_conf_threshold, nms_threshold, scale_w, scale_h, 
367.                     out_zps, out_scales, &detect_result_group);
368.
369.        // Draw Objects
370.        char text[256];
371.        for (int i = 0; i < detect_result_group.count; i++) {
372.            detect_result_t* det_result = &(detect_result_group.results[i]);
373.
374.            int x1 = det_result->box.left;
375.            int y1 = det_result->box.top;
376.            int x2 = det_result->box.right;
377.            int y2 = det_result->box.bottom;
378.            
379.            cv::rectangle(orig_img, cv::Point(x1, y1), cv::Point(x2, y2), cv::Scalar(0, 255, 0), 2);
380.
381.            sprintf(text, "%s %.1f%%", det_result->name, det_result->prop * 100);
382.
383.            int baseLine = 0;
384.            cv::Size label_size = cv::getTextSize(text, cv::FONT_HERSHEY_SIMPLEX, 0.5, 1, &baseLine);
385.
386.            int x = det_result->box.left;
387.            int y = det_result->box.top - label_size.height - baseLine;
388.            if (y < 0) y = 0;
389.            if (x + label_size.width > orig_img.cols) x = orig_img.cols - label_size.width;
390.
391.            cv::rectangle(orig_img, cv::Rect(cv::Point(x, y), cv::Size(label_size.width, label_size.height + baseLine)), 
392.                         cv::Scalar(0, 255, 0), -1);
393.
394.            cv::putText(orig_img, text, cv::Point(x, y + label_size.height), 
395.                       cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0), 1);
396.        }
397.
398.        ret = rknn_outputs_release(ctx, io_num.n_output, outputs);
399.
400.        Tend = std::chrono::steady_clock::now();
401.        
402.        // è®¡ç®— FPS
403.        f = std::chrono::duration_cast <std::chrono::milliseconds> (Tend - Tbegin).count();
404.        if(f>0.0) FPS[((Fcnt++)&0x0F)]=1000.0/f;
405.        for(f=0.0, i=0;i<16;i++){ f+=FPS[i]; }
406.        
407.        // æ˜¾ç¤ºä¿¡æ¯
408.        if (SHOW_FPS) {
409.            putText(orig_img, cv::format("FPS: %.2f", f/16), cv::Point(10, 30), 
410.                   cv::FONT_HERSHEY_SIMPLEX, 0.8, cv::Scalar(0, 0, 255), 2);
411.        }
412.        
413.        putText(orig_img, cv::format("Camera: %d", g_current_camera.load()), cv::Point(10, 60), 
414.               cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(255, 255, 0), 2);
415.        
416.        putText(orig_img, cv::format("Objects: %d", detect_result_group.count), cv::Point(10, 90), 
417.               cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 255, 0), 2);
418.        
419.        putText(orig_img, cv::format("Frame: %d", frame_count), cv::Point(10, 120), 
420.               cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(255, 255, 0), 2);
421.
422.        // æ˜¾ç¤ºç»“æœ
423.        imshow(WINDOW_TITLE, orig_img);
424.        
425.        // é”®ç›˜æ§åˆ¶ï¼ˆESCé€€å‡ºï¼‰
426.        char key = cv::waitKey(1);
427.        if(key == 27) {
428.            printf("\nğŸ›‘ ESC pressed, exiting...\n");
429.            g_running = false;
430.            break;
431.        }
432.    }
433.
434.    // æ¸…ç†èµ„æº
435.    printf("\nğŸ§¹ Cleaning up...\n");
436.    cap.release();
437.    cv::destroyAllWindows();
438.    ret = rknn_destroy(ctx);
439.
440.    printf("âœ… Done! Total frames processed: %d\n", frame_count);
441.
442.    return 0;
443.}
444.